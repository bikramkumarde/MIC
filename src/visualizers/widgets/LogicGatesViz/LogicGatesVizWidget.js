/*globals define, WebGMEGlobal*/

/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Fri Nov 22 2019 21:27:20 GMT-0600 (Central Standard Time).
 */

define(['jointjs','css!./styles/LogicGatesVizWidget.css','css!jointjsCSS'], function (joint) {
    'use strict';

    var WIDGET_CLASS = 'logic-gates-viz';

    function LogicGatesVizWidget(logger, container) {
        this._logger = logger.fork('Widget');

        this._el = container;

        this.nodes = {};
        this._initialize();

        this._logger.debug('ctor finished');
    }

    LogicGatesVizWidget.prototype._initialize = function () {
        var width = this._el.width(),
            height = this._el.height(),
            self = this;

        // set widget class
        this._el.addClass(WIDGET_CLASS);

        // Create a dummy header
        this._el.append('<div id="myholder"></div>');

        // Registering to events can be done with jQuery (as normal)
        //this._el.on('dblclick', function (event) {
        //    event.stopPropagation();
        //    event.preventDefault();
        //    self.onBackgroundDblClick();
        //});
    };

    LogicGatesVizWidget.prototype.onWidgetContainerResize = function (width, height) {
        this._logger.debug('Widget is resizing...');
    };

    LogicGatesVizWidget.prototype.setLogicGate = function(desc) {
      // Get information from desc
      const self = this;

      // Create and fill information arrays
      this.gateIds2Names = {};
      this.connIds2Src = {};
      this.connIds2Dst = {};
      this.ioIds2Names = {};
      this.port2parent = {};
      this.id2GraphId = {};

      desc.ports.forEach(function(port) {
        self.port2parent[port.id] = port.parentId;
      });

      desc.gates.forEach(function(gate){
          self.gateIds2Names[gate.id] = gate.name;
      });

      desc.connect.forEach(function(connection) {
          self.connIds2Src[connection.id] = connection.src;
          self.connIds2Dst[connection.id] = connection.dst;
      });

      desc.io.forEach(function(IO) {
        self.ioIds2Names[IO.id] = IO.name;
      })

      // Visualization via JointJS
      var graph = new joint.dia.Graph;

      var paper = new joint.dia.Paper({
            el: document.getElementById('myholder'),
            model: graph,
            width: '100%',
            height: '100%',
            gridSize: 1,
            defaultLink: new joint.shapes.standard.Link,
            interactive: false,
            validateConnection: function(vs, ms, vt, mt, e, vl) {

                if (e === 'target') {

                    // target requires an input port to connect
                    if (!mt || !mt.getAttribute('class') || mt.getAttribute('class').indexOf('input') < 0) return false;

                    // check whether the port is being already used
                    var portUsed = this.model.getLinks().some(function(link) {
                        return (link.id !== vl.model.id &&
                                link.get('target').id === vt.model.id &&
                                link.get('target').port === mt.getAttribute('port'));
                    });

                    return !portUsed;

                } else { // e === 'source'

                    // source requires an output port to connect
                    return ms && ms.getAttribute('class') && ms.getAttribute('class').indexOf('output') >= 0;
                }
            }
        });

        paper.on('element:pointerclick', function(elementView) {
            var currentElement = elementView.model;

            // Allow user to toggle the input via a click
            if (currentElement.attr('text/text') === '0') {
              currentElement.attr('text/text','1')
            } else if (currentElement.attr('text/text') === '1') {
              currentElement.attr('text/text','0')
            }
        });

        // Add user input/output to the graph
        var inputy = 50;
        desc.io.forEach(function(IO){
          var addIO;
          if (self.ioIds2Names[IO.id] == 'UserInput'){
            addIO = new joint.shapes.logic.Input({ position: { x: 50, y: inputy }});
            inputy += 50;
            addIO.attr({
              text: { text: '0'}
            })

          } else if (self.ioIds2Names[IO.id] == 'UserOutput'){
            addIO = new joint.shapes.logic.Output({ position: { x: 700, y: 300 }});
          }

          self.id2GraphId[IO.id] = addIO.id;
          graph.addCells(addIO);
        });

        // Add gates to the graph
        var gatey = 50;
        desc.gates.forEach(function(gate){
            var addGate;
            if (self.gateIds2Names[gate.id] == 'AND') {
              addGate = new joint.shapes.logic.And({ position: { x: 375, y: gatey }})
            } else if (self.gateIds2Names[gate.id] == 'OR') {
              addGate = new joint.shapes.logic.Or({ position: { x: 375, y: gatey }});
            } else if (self.gateIds2Names[gate.id] == 'NOT') {
              addGate = new joint.shapes.logic.Not({ position: { x: 375, y: gatey }});
            }
            gatey += 100;
            self.id2GraphId[gate.id] = addGate.id;
            graph.addCells(addGate);
        });

        // Get connections
        var wires = [];
        desc.connect.forEach(function(connection) {
          var srcId = self.port2parent[self.connIds2Src[connection.id]];
          var dstId = self.port2parent[self.connIds2Dst[connection.id]];
          wires.push({source: { id: self.id2GraphId[srcId], port: 'out' }, target: { id: self.id2GraphId[dstId], port: 'in' }});
        });

        // Add connections to the graph
        joint.util.forIn(wires, function(attributes) {
            graph.addCell(paper.getDefaultLink().set(attributes));
        });


    }

    // Adding/Removing/Updating items
    LogicGatesVizWidget.prototype.addNode = function (desc) {
        /*if (desc) {
            // Add node to a table of nodes
            var node = document.createElement('div'),
                label = 'children';

            if (desc.childrenIds.length === 1) {
                label = 'child';
            }

            this.nodes[desc.id] = desc;
            node.innerHTML = 'Adding node "' + desc.name + '" (click to view). It has ' +
                desc.childrenIds.length + ' ' + label + '.';

            this._el.append(node);
            node.onclick = this.onNodeClick.bind(this, desc.id);
        }*/
    };

    LogicGatesVizWidget.prototype.removeNode = function (gmeId) {
        /*var desc = this.nodes[gmeId];
        this._el.append('<div>Removing node "' + desc.name + '"</div>');
        delete this.nodes[gmeId];*/
    };

    LogicGatesVizWidget.prototype.updateNode = function (desc) {
        /*if (desc) {
            this._logger.debug('Updating node:', desc);
            this._el.append('<div>Updating node "' + desc.name + '"</div>');
        }*/
    };

    /* * * * * * * * Visualizer event handlers * * * * * * * */

    LogicGatesVizWidget.prototype.onNodeClick = function (/*id*/) {
        // This currently changes the active node to the given id and
        // this is overridden in the controller.
    };

    LogicGatesVizWidget.prototype.onBackgroundDblClick = function () {
        this._el.append('<div>Background was double-clicked!!</div>');
    };

    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    LogicGatesVizWidget.prototype.destroy = function () {
    };

    LogicGatesVizWidget.prototype.onActivate = function () {
        this._logger.debug('LogicGatesVizWidget has been activated');
    };

    LogicGatesVizWidget.prototype.onDeactivate = function () {
        this._logger.debug('LogicGatesVizWidget has been deactivated');
    };

    return LogicGatesVizWidget;
});
